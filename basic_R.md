Session 1: Basic R
================
Bioinformatics Hub
1 March 2019

# Overview

In this tutorial, we introduce basic R functions and objects, such as
vectors, matrices and data frames.

After this tutorial you will be able to:

  - Create vectors, matrices and data frames in R.
  - Access and change the values of the elements in vectors, matrices
    and data frames.
  - Understand what is logical indexing and why it is so useful in data
    analysis with R.

# Using R Markdown

The tutorial that follows was created using R Markdown. As an exercise
in using R Markdown, here, we ask you to save your work in an R Markdown
file. By the end of this session, you will have recreated the .Rmd file
of this tutorial. You don’t have to retype the instruction and comments.
Focus only on the R code and add notes that are useful for your own
understanding.

To create an R Markdown file:

  - Choose **File** -\> **New File** -\> **R Markdown…** from RStudio
    menu.
  - Save this file with the name **basic\_R.Rmd** in your working
    directory. Don’t change the other R Markdown options.
  - From R studio menu use **Code** -\> **Insert Chunk** to add boxes to
    save R code.

You may use the R Markdown cheat sheet
<https://www.rstudio.com/wp-content/uploads/2015/02/rmarkdown-cheatsheet.pdf>
to further format the output of the R Markdown file.

# R Markdown setup

This is generated by default when we create an R Markdown file.

``` r
knitr::opts_chunk$set(echo = TRUE)
```

# Hello world\!

Learning a programming language always starts with a simple piece of
code that when executed shows a message on the computer screen (usually
“Hello World\!”). To print a message on the screen (R console) in R,
we can use the `print()` function, specifying within the brackets our
message (enclosed in double quotes).

``` r
print("Hello World!")
```

    ## [1] "Hello World!"

We can get the same result by simply typing.

``` r
"Hello World!"
```

    ## [1] "Hello World!"

**Question**: Can you think of any differences between the two examples
above?

# Calculations

We can use R for simple calculation such as additions, multiplications,
divisions, etc.

``` r
2+3
```

    ## [1] 5

``` r
8-5
```

    ## [1] 3

``` r
4*3
```

    ## [1] 12

``` r
6/4
```

    ## [1] 1.5

``` r
2^3
```

    ## [1] 8

``` r
2+3*5
```

    ## [1] 17

``` r
(2+3)*5
```

    ## [1] 25

``` r
5^3
```

    ## [1] 125

``` r
pi  # this is a built-in constant
```

    ## [1] 3.141593

**Question**: What is the function of the `^` operator?

# Mathematical Functions

R has also build-in mathematical functions such as sin, cos, log, abs.

``` r
sqrt(2)
```

    ## [1] 1.414214

``` r
sin(pi/3)                   
```

    ## [1] 0.8660254

``` r
sin(pi/3)^2 + cos(pi/3)^2
```

    ## [1] 1

``` r
exp(1)
```

    ## [1] 2.718282

``` r
log(10)                     
```

    ## [1] 2.302585

``` r
log2(8)                   
```

    ## [1] 3

``` r
abs(-3)
```

    ## [1] 3

``` r
# nesting functions is possible (calculated from inside to outside)
log(exp(10))                
```

    ## [1] 10

**Question**: What is the difference between the `log()` and the
`log2()` function? Can you think of any application for these functions
that are relevant to the analysis of biological data?

# Objects

Most of the time we don’t deal with constant values like the examples
above, but with objects. An object points to a specific slot of the
computer’s memory, where our data are stored. There are different types
(or classes) of objects: numeric, character, logical (true or false),
and more complex ones that we will see in later tutorials. We can check
the class of an object with the `class()` function, and we can assign
values to objects using the assignment operator `<-`.

``` r
x <- 1
print(x)
```

    ## [1] 1

``` r
# or simply
x                           
```

    ## [1] 1

``` r
# we can change the value of an object by re-assigning a new value
x <- 2                      
print(x)
```

    ## [1] 2

``` r
# we can do simple calculations with objects...
y <- 3
x + y                         
```

    ## [1] 5

``` r
# ...and assign the result to a new object
z <- x*y                      
print(z)
```

    ## [1] 6

``` r
# objects may be characters or strings (many characters joined together). 
# Note that the value of a character object is enclosed in double quotes.
ch <- "a"                   
name <- "Mary"

# we can check the class of objects with the class() function
class(name)
```

    ## [1] "character"

``` r
class(x)
```

    ## [1] "numeric"

``` r
# when we do arithmetic that doesn't make sense, we get errors such as 
# the one below (uncomment the command below and run to see the error 
# message).

# name + 2                  

# logical objects have only two possible values (TRUE/FALSE)
significant <- TRUE         
print(significant)
```

    ## [1] TRUE

``` r
# The result of a comparison between numbers (>, >=, <, <=, ==, !=) 
# is a logical
z == (x+y)
```

    ## [1] FALSE

``` r
# we can assign the result of a comparison to a logical object
is_equal <- (z == (x+y))
print(is_equal)
```

    ## [1] FALSE

**Question**: How would you use logical objects in the context of
statistical analysis?

# Vectors

## Creating a vector and basic vector calculations

Have you noticed that when we print the value of an object, we always
get a `[1]` in front of the value? This is because R considers all
objects to be vectors, even when there is only one element within the
vector. The `[1]` refers to this first element of the vector. Vectors
are ordered collections of values that can be effectively accessed and
manipulated. The easiest way to create a vector is by using the combine
function `c()`.

``` r
# c (combine) creates a vector element-by-element
v <- c(3,4,5,6,7)

# Note that x is not a new class, it's numeric.
class(v)
```

    ## [1] "numeric"

``` r
# If our vector consists of characters the result would be character.
abc <- letters  # like pi, "letters" is a built-in constant
print(abc)
```

    ##  [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q"
    ## [18] "r" "s" "t" "u" "v" "w" "x" "y" "z"

``` r
class(abc)
```

    ## [1] "character"

``` r
# For number sequences we don't need to explicitly write all elements. 
# We can use the function seq().
seq(from = 1, to = 5, by = 1)
```

    ## [1] 1 2 3 4 5

``` r
u <- seq(from = 1, to = 5, by = 1)             

# ... or simply
u <- 1:5                                        

# Sometimes vectors consist of thousands of elements and it is 
# difficult to know exactly how many by printing them on the screen. 
# The function length() returns the number of elements in a vector.
length(u)                                       
```

    ## [1] 5

``` r
# We can do some simple vector algebra (element-by-element).
2*v
```

    ## [1]  6  8 10 12 14

``` r
v+u
```

    ## [1]  4  6  8 10 12

``` r
v*u
```

    ## [1]  3  8 15 24 35

``` r
v/u
```

    ## [1] 3.000000 2.000000 1.666667 1.500000 1.400000

``` r
# Vectors may also consist of strings, in this case gene names.
genes <- c("PTEN", "p53", "MYC", "PI3K")
print(genes)
```

    ## [1] "PTEN" "p53"  "MYC"  "PI3K"

## Accessing vectors

To access the elements of a vector we need to refer to them with another
vector (index vector) that indicates the position of these elements.

``` r
# Here, we access the third element in the vector genes. The vector "3" 
# is the index vector.
genes[3]
```

    ## [1] "MYC"

``` r
# Here, we access the first three elements. The index vector is 1,2,3.
genes[1:3]
```

    ## [1] "PTEN" "p53"  "MYC"

``` r
# All but the first element.
genes[-1]              
```

    ## [1] "p53"  "MYC"  "PI3K"

``` r
# The first and the fourth element.
genes[c(1,4)]        
```

    ## [1] "PTEN" "PI3K"

``` r
# If the index vector refers to a non-existing element, we get an NA 
# (Not Available) value, as shown below for the 5th (non-existing) 
# element.

genes[1:5]
```

    ## [1] "PTEN" "p53"  "MYC"  "PI3K" NA

``` r
# The index vector doesn't have to be a numeric vector. It can also 
# be a logical vector.

loss_of_function <- c(TRUE, TRUE, FALSE, FALSE)
genes[loss_of_function]
```

    ## [1] "PTEN" "p53"

``` r
# this is equivalent with
genes[c(1,2)]
```

    ## [1] "PTEN" "p53"

**Exercise**: How do we make `letters` appear in reverse order? i.e. `z
y x ... c b a`

## Manipulating vectors

We can change one or more than one values of a vector by referring to
these elements and assigning the new value(s).

``` r
# Here, we decided to change the name "MYC" to "cMYC"
genes[3] <- "cMYC"
print(genes)
```

    ## [1] "PTEN" "p53"  "cMYC" "PI3K"

``` r
# If the genes vector above contained thousands of genes names, it would 
# not be easy to identify the position of the element we needed to change.
# We can avoid referring to the position of that element by using logical 
# indexing.

# Note that only the 3rd element is TRUE
genes == "cMYC"      
```

    ## [1] FALSE FALSE  TRUE FALSE

``` r
# Now we can use the logical vector as an index vector for accessing and 
# changing the value of "cMYC" back to "MYC"
genes[genes == "cMYC"] <- "MYC"

print(genes)
```

    ## [1] "PTEN" "p53"  "MYC"  "PI3K"

# Matrices

Matrices are two-dimensional arrays that can be useful for organizing
data that are related to each other. For example, rows may represent
genes and columns may represent samples. We are only going to use
matrices for storing data in this course and not for matrix algebra.

## Creating a matrix

We can create a matrix with the `matrix()` function or by binding
vectors as shown in the examples below.

``` r
# Here, all elements of the matrix are going to have the same value.
# This is an easy way to create a matrix of the right dimensions.
# Later, we cn replace the data with more meaningful values.
matrix(data = 1, nrow = 2, ncol = 3)            
```

    ##      [,1] [,2] [,3]
    ## [1,]    1    1    1
    ## [2,]    1    1    1

``` r
# Another way to create a matrix is by binding vectors. Here, we bind 
# vectors with our data.
sample1 <- c(17, 7, 185, 123)                    
sample2 <- c(25, 15, 8, 99)
sample3 <- c(1, 0, 0, 1)

# column bind
M <- cbind(sample1, sample2, sample3)
print(M)
```

    ##      sample1 sample2 sample3
    ## [1,]      17      25       1
    ## [2,]       7      15       0
    ## [3,]     185       8       0
    ## [4,]     123      99       1

``` r
# We can also use the rbind() function if we want to combine vectors 
# row-by-row.

# Matrices have row names and column names. 
colnames(M)   
```

    ## [1] "sample1" "sample2" "sample3"

``` r
rownames(M)
```

    ## NULL

``` r
# Here, column names came from the vectors that we combined together 
# with the functions cbind(), but row names remain unspecified. 

# We can define row names with the function rownames()
rownames(M) <- c("PTEN", "p53", "MYC", "PI3K")
print(M)
```

    ##      sample1 sample2 sample3
    ## PTEN      17      25       1
    ## p53        7      15       0
    ## MYC      185       8       0
    ## PI3K     123      99       1

**Question:** What is the class of M? How is it different from the
vectors you have seen so far?

## Accessing and manipulating matrices

We can access and manipulate elements of a matrix the same way as we did
with vectors, but using two indices instead of one. The first index
refers to the rows (horizontal slices of the matrix) and the second to
the columns (vertical slices of the data). The general notation is:
**matrix\[row\_index, column\_index\]**. Where `row_index` and
`column_index` are vectors within the dimensions of this matrix.

``` r
# This is the first column (the lack of index in the row-position 
# means "all rows")
M[,1]
```

    ## PTEN  p53  MYC PI3K 
    ##   17    7  185  123

``` r
# Second colummn. Again empty means "all columns"
M[2,]
```

    ## sample1 sample2 sample3 
    ##       7      15       0

``` r
# Getting a submatrix
M[2:3,1:2]
```

    ##     sample1 sample2
    ## p53       7      15
    ## MYC     185       8

``` r
# We can change one or many elements of a matrix at the same time.
M[c(1,4), 3] <- c(0,0)

# We can also add more columns or row to a matrix
M_new <- cbind(M, c(23, 15, 11, 8))
print(M_new)
```

    ##      sample1 sample2 sample3   
    ## PTEN      17      25       0 23
    ## p53        7      15       0 15
    ## MYC      185       8       0 11
    ## PI3K     123      99       0  8

**Question**: What is the difference between `M_new <- cbind(M, sample4
= c(23, 15, 11, 8))` and the syntax used to define `M_new` above?

## Logical indexing

We have already seen that we can access elements of a vector using
logical indices. We can do the same with matrices. A common application
of logical indexing is to exclude samples of poor quality or probeset
ids/genes from further analysis.

In the case of matrix `M`, it is obvious that something is wrong with
sample (column) \#3, so we would like to exclude it from further
analysis. We can define a filter that removes samples with all zero
entries using logical indexing.

``` r
# Note that sample 3 is of poor quality and we would like to exclude it.
M
```

    ##      sample1 sample2 sample3
    ## PTEN      17      25       0
    ## p53        7      15       0
    ## MYC      185       8       0
    ## PI3K     123      99       0

``` r
# We could simply remove the 3rd column by referring to this column 
# specifically. E.g.
M[,-3]
```

    ##      sample1 sample2
    ## PTEN      17      25
    ## p53        7      15
    ## MYC      185       8
    ## PI3K     123      99

``` r
# but a more realistic dataset will typically include hundreds of samples. 
# It's best to find a more effective way to define "poor quality" samples. 
# Let's assume this criterion is at least one non-zero value in any of the
# genes.

# colSums() will calculate the sum for all values for each column.
colSums(M)
```

    ## sample1 sample2 sample3 
    ##     332     147       0

``` r
# We keep only samples with at least one non-zero entry.
colSums(M) != 0
```

    ## sample1 sample2 sample3 
    ##    TRUE    TRUE   FALSE

``` r
keep <- colSums(M) != 0

# Submatrix with the good quality samples.
M_qc <- M[,keep]

print(M_qc)
```

    ##      sample1 sample2
    ## PTEN      17      25
    ## p53        7      15
    ## MYC      185       8
    ## PI3K     123      99

## Matrices vs. data frames

Matrices can store only one class of data, e.g. only numeric data or
only characters. When we mix different classes of data in a matrix, the
values are converted into a class that can represent all the other
classes. For example when we store numeric and character data, all of
them will be converted into characters, as shown in the example below.

``` r
mixed <- cbind(symbol = c("PTEN", "p53", "MYC", "PI3K"),
               exprs = c(17, 185, 7, 123), 
               loss.of.function = c(TRUE, FALSE, FALSE, TRUE))
print(mixed)
```

    ##      symbol exprs loss.of.function
    ## [1,] "PTEN" "17"  "TRUE"          
    ## [2,] "p53"  "185" "FALSE"         
    ## [3,] "MYC"  "7"   "FALSE"         
    ## [4,] "PI3K" "123" "TRUE"

``` r
# Note the double quotes in the columns "exprs" and "loss.of.function".
# This means that the numeric and logical data have been converted to 
# character data.

# On the contrary data frames are two dimensional arrays similar to 
# matrices, but can store also different objects.

mixed_df <- data.frame(symbol = c("PTEN", "p53", "MYC", "PI3K"),
                       exprs = c(17, 185, 7, 123), 
                       loss.of.function = c(TRUE, FALSE, FALSE, TRUE))
class(mixed_df)
```

    ## [1] "data.frame"

``` r
print(mixed_df)
```

    ##   symbol exprs loss.of.function
    ## 1   PTEN    17             TRUE
    ## 2    p53   185            FALSE
    ## 3    MYC     7            FALSE
    ## 4   PI3K   123             TRUE

``` r
# Note that each column of mixed_df is of a different class.
```
